<!doctype html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>Raycaster Demo - PlayfulJS</title>
	<script src="./mazegenerator.js"></script>
</head>
<body style='background: #000; margin: 0; padding: 0'>
	<canvas id='display' width='1' height='1' style='width: 100%; height: 100%;' />
	<script>
	var CIRCLE = Math.PI * 2;

	function Controls() {
		"use strict";
		this.codes  = { 37: 'left', 39: 'right', 38: 'forward', 40: 'backward' };
		this.states = { 'left': false, 'right': false, 'forward': false, 'backward': false };
		document.addEventListener('keydown', this.onKey.bind(this, true), false);
		document.addEventListener('keyup', this.onKey.bind(this, false), false);
	}

	Controls.prototype.onKey = function(val, e) {
		"use strict";
		var state = this.codes[e.keyCode];
		if (typeof state === 'undefined') return;
		this.states[state] = val;
		e.preventDefault && e.preventDefault();
		e.stopPropagation && e.stopPropagation();
	};

	function Bitmap(src, width, height) {
		"use strict";
		this.image = new Image();
		this.image.src = src;
		this.width = width;
		this.height = height;
	}

	function Player(pos, direction) {
		"use strict";
		this.pos = pos;
		this.rotation = 0;
		this.speed = 0;
		this.direction = direction;
	}

	Player.prototype.rotate = function(angle) {
		"use strict";
		var x = this.direction[0],
			y = this.direction[1],
			cos = Math.cos(angle),
			sin = Math.sin(angle);
		this.direction = [x*cos - y*sin, x*sin + y*cos];
	};

	Player.prototype.walk = function(distance, map) {
		"use strict";
		var dir = this.direction,
			pos = this.pos,
			dx = dir[0] * distance,
			dy = dir[1] * distance;
		if (map.get(Math.floor(pos[0] + dx), Math.floor(pos[1])) <= 0) pos[0] += dx;
		if (map.get(Math.floor(pos[0]), Math.floor(pos[1] + dy)) <= 0) pos[1] += dy;
	};

	Player.prototype.update = function(controls, map, seconds) {
		"use strict";
		if (controls.right){
			if(this.rotation < Math.PI){ this.rotation += seconds * Math.PI/6; }
		} else if (controls.left){
			if(this.rotation > -Math.PI){ this.rotation -= seconds * Math.PI/6; }
		} else {
			this.rotation /= Math.pow(3,seconds);
		}
		
		if (controls.forward){
			if(this.speed < 10){ this.speed += .5*seconds; }
		} else if (controls.backward){
			if(this.speed > -10){ this.speed -= .5*seconds; }
		} else {
			this.speed /= Math.pow(3,seconds);
		}

		if(Math.abs(this.speed) < .01){ this.speed = 0; }
		if(Math.abs(this.rotation) < .01){ this.rotation = 0; }

		this.walk(this.speed * seconds, map);
		this.rotate(this.rotation * seconds);
	};

	function GameMap(width, height) {
		"use strict";
		this.width = width;
		this.height = height;
		this.wallGrid = new Uint16Array(width * height);
		this.skybox = new Bitmap('./deathvalley_panorama.jpg', 4000, 1290);
		this.textures = [
			new Bitmap('./texture1.jpg', 1024, 1024),
			new Bitmap('./texture2.jpg', 1024, 1024),
			new Bitmap('./texture3.jpg', 1024, 1024),
			new Bitmap('./texture4.jpg', 1024, 1024)
		];
	}

	GameMap.prototype.get = function(x, y) {
		"use strict";
		x %= this.width;
		y %= this.height;
		if(x < 0){ x += this.width; }
		if(y < 0){ y += this.height; }
		return this.wallGrid[y * this.width + x];
	};

	GameMap.prototype.randomize = function(fraction) {
		"use strict";
		var i, len = this.width * this.height;
		for (var i = 0; i < len; i++) {
			this.wallGrid[i] = Math.random() < fraction ? Math.floor(Math.random()*256) + 1 : 0;
		}
	};

	GameMap.prototype.maze = function(fraction){
		"use strict";
		var i, j, row,
			offset = 0,
			len = this.width * this.height,
			texture = Math.floor(Math.random()*256) + 1,
			maze = Maze(this.width/2,this.height/2);
		for(i = 0; i < this.height; i++, offset += this.width){
			row = maze[i];
			for(j = 0; j < this.width; j++){
				this.wallGrid[offset + j] = row[j]*texture;
			}
		}
		this.wallGrid[0] = 0;
		for (i = 0; i < len; i++) {
			if(Math.random() < fraction){ this.wallGrid[i] = 0; }
		}
	};

	GameMap.prototype.cast = function(point, vector, range) {
		"use strict";
		var cos = vector[0];
		var sin = vector[1];

		// Starting from the player, we find the nearest horizontal and vertical gridlines. We move to whichever is closer and check for a wall (inspect). Then we repeat until we've traced the entire length of each ray.

		var mx, my, sx, sy, dx, dy,
			xdelta, ydelta,
			xdist, ydist,
			value, dim,
			x = point[0],
			y = point[1],
			distance = 0,
			tan = sin/cos,
			cot = cos/sin;

		xdelta = Math.abs(1/cos);
		ydelta = Math.abs(1/sin);

		if(cos > 0){
			sx = 1;
			mx = Math.floor(x);
			dx = mx + 1 - x;
		}else{
			sx = -1;
			mx = Math.ceil(x - 1);
			dx = mx - x;
		}
		dy = dx * tan;
		xdist = Math.sqrt(dx*dx + dy*dy);

		if(sin > 0){
			sy = 1;
			my = Math.floor(y);
			dy = my + 1 - y;
		}else{
			sy = -1;
			my = Math.ceil(y - 1);
			dy = my - y;
		}
		dx = dy * cot;
		ydist = Math.sqrt(dx*dx + dy*dy);

		do {
			if(xdist < ydist){
				dim = 0;
				mx += sx;
				distance = xdist;
				xdist += xdelta;
			}else{
				dim = 1;
				my += sy;
				distance = ydist;
				ydist += ydelta;
			}
			value = this.get(mx, my);
		} while(value === 0 && distance < range);

		x += distance * cos;
		y += distance * sin;

		return {
			x: x, y: y,
			vector: vector,
			dimension: dim,
			value: value,
			distance: distance
		};
	};

	function Camera(canvas, resolution, fov) {
		"use strict";
		var col, scale, angle, cos,
			sines = new Float32Array(resolution),
			cosines = new Float32Array(resolution),
			ranges = new Uint32Array(resolution);
		this.ctx = canvas.getContext('2d');
		this.width = canvas.width = window.innerWidth * 0.5;
		this.height = canvas.height = window.innerHeight * 0.5;
		this.resolution = resolution;
		this.spacing = this.width / resolution;
		this.fov = fov;
		this.lightRange = 20;
		this.sines = sines;
		this.cosines = cosines;
		this.ranges = ranges;
		this.fps = [];

		scale = Math.tan(fov/2);
		for (col = 0; col < resolution; col++) {
			angle = Math.atan(scale*(col / resolution - 0.5));
			cos = Math.cos(angle);
			sines[col] = Math.sin(angle);
			cosines[col] = cos;
			ranges[col] = Math.round(this.height / cos);
		}
	}

	Camera.prototype.render = function(player, map, seconds) {
		"use strict";
		var fps;
		this.drawSky(player.direction, map.skybox, map.light);
		this.drawColumns(player, map);
		if(this.fps.length > 20){ this.fps.shift(); }
		this.fps.push(1/seconds);
		fps = this.fps.reduce(function(a,n){ return a + n; })/this.fps.length;
		this.ctx.fillStyle = "#ffffff";
		this.ctx.font = "12px Arial";
		this.ctx.fillText(Math.round(fps).toString()+" FPS", 25, 25);
	};

	Camera.prototype.drawSky = function(direction, sky, ambient) {
		"use strict";
		var width = this.width * (CIRCLE / this.fov);
		var acos = Math.acos(direction[0]);
		var left = -width * (acos + (direction[1] > 0 ? 0 : 2 * (Math.PI - acos))) / CIRCLE;

		this.ctx.save();
		this.ctx.drawImage(sky.image, left, 0, width, this.height);
		if (left < width - this.width) {
			this.ctx.drawImage(sky.image, left + width, 0, width, this.height);
		}
		if (ambient > 0) {
			this.ctx.fillStyle = '#ffffff';
			this.ctx.globalAlpha = ambient * 0.1;
			this.ctx.fillRect(0, this.height * 0.5, this.width, this.height * 0.5);
		}
		this.ctx.restore();
	};

	Camera.prototype.drawColumns = function(player, map) {
		"use strict";
		var res = this.resolution,
			sines = this.sines,
			cosines = this.cosines,
			ranges = this.ranges,
			height = this.height,
			dir = player.direction,
			pcos = dir[0], psin = dir[1],
			rcos, rsin, col, ray;
		this.ctx.save();
		for (col = 0; col < res; col++) {
			rsin = sines[col];
			rcos = cosines[col];
			ray = map.cast(player.pos, [pcos*rcos-psin*rsin, psin*rcos+pcos*rsin], ranges[col]);
			if(ray.value > 0){ this.drawColumn(col, ray, rcos, map); }
		}
		this.ctx.restore();
	};

	var shades = [.25,.25,.66,1];
	Camera.prototype.drawColumn = function(column, ray, scale, map) {
		"use strict";
		var ctx = this.ctx;
		var left = Math.floor(column * this.spacing);
		var width = Math.ceil(this.spacing);
		var value = ray.value - 1; //so we can use the 0 index
		var dim = ray.dimension;
		var side = dim + (ray.vector[dim] > 0 ? 0 : 2);
		var offset = dim === 0 ? ray.y - Math.floor(ray.y) : ray.x - Math.floor(ray.x);
		var texture = map.textures[(value >> (side * 2)) & 3];

		var wallHeight = this.height / (ray.distance * scale);
		var top = (this.height - wallHeight) / 2;

		ctx.globalAlpha = 1;
		ctx.drawImage(texture.image, texture.width * offset, 0, 1, texture.height, left, top, width, wallHeight);

		ctx.fillStyle = '#000000';
		ctx.globalAlpha = ((ray.distance / this.lightRange) + shades[side]) / 2;
		ctx.fillRect(left, top, width, wallHeight);
	};

	function GameLoop(body) {
		"use strict";
		this.lastTime = 0;
		this.body = body;
		this.stop = false;
	}

	GameLoop.prototype.start = function() {
		"use strict";
		var that = this;
		requestAnimationFrame(function frame(time) {
			var seconds = (time - that.lastTime) / 1000;
			that.lastTime = time;
			that.body(seconds);
			if(!that.stop){ requestAnimationFrame(frame); }
		});
	};

	var display = document.getElementById('display');
	var map = new GameMap(16,64);
	var player = new Player([.3, .3], [1, 0]);
	var controls = new Controls();
	var camera = new Camera(display, 640, Math.PI * 0.4);
	var loop = new GameLoop(function(seconds){
		player.update(controls.states, map, seconds);
		camera.render(player, map, seconds);
	});

	//map.randomize(.001);
	map.maze(.05);
	loop.start();

	//setTimeout(function(){ loop.stop = true; }, 1000);

	</script>
</body>
</html>
